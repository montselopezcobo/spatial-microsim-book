# Optimisation experiments
source("R/SimpleWorld.R")
library(microbenchmark)
library(ggplot2)

# Look at the set-up data
x0
cons
ind
ind_cat

# Creating the function to optimise
# Setting up the input data
# ind_cat <- rbind(ind_cat, ind_cat[1,]) # add extra rows - just for testing
# indu <- unique(ind_cat) # save only unique individuals - dplyr::distinct forgets row.names

umat_count <- function(x) {
  xp <- apply(x, 1, paste0, collapse = "") # "pasted" version of constraints
  freq <- table(xp) # frequency of occurence of each individual
  xu <- unique(x) # save only unique individuals
  rns <- as.integer(row.names(xu)) # save the row names of unique values of ind
  xpu <- xp[rns]
  o <- order(xpu, decreasing = TRUE) # the order of the output (to rectify table)
  cbind(xu, data.frame(ind_n = freq[o], rns = rns)) # outputs
}

umat <- umat_count(ind_cat) 
indu <- apply(umat[1:ncol(ind_cat)], 2,
              function(x) x * umat$ind_n.Freq)

sim <- colSums(indu * c(1.2,3.5,1.5,4.5)) # test it on approximate dataset
sim - cons[1,] # test the function works

fun <- function(par, ind_n.Freq, con){
  sim <- colSums(par * ind_n.Freq)
  ae <- abs(sim - con) # Absolute error per category
  sum(ae) # the Total Absolute Error (TAE)
}
par <- c(1.2,3.5,1.5,4.5)
fun(par, indu, cons[1,]) # Shows the function in action

# Test the function on the weights obtained by IPF
# fun(weights[rns,1], indu, cons[1,]) # the weights generated by ipfp result in a tae of 0, better than optim

ores <- optim(par = rep(1, nrow(indu)), fn = fun, gr = "CG", ind_n.Freq = indu, con = cons[1,])
ores$par
fun(ores$par, indu, cons[1,]) # check TAE is low
fw <- ores$par[rep(1:nrow(umat), times = umat$ind_n.Freq)] # final weights

umat[1:ncol(ind_cat)][rep(1:nrow(umat), umat$ind_n.Freq),] # we've returned full circle to the correct population

# Next stage: try optimising the fit using diferent algorithms and do tests!

optim_optim_CG <- function(){
  optim(par = rep(1, nrow(indu)), fn = fun, gr = "CG", ind_n.Freq = indu, con = cons[1,])
}

# GenSA test
library(GenSA) # the library to test
out <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^5, nrow(indu)), control = list(maxit = 10), ind_n.Freq = indu, con = cons[1,])
out$value

# rgenoud 
# install.packages("rgenoud")
library(rgenoud)
set.seed(2014)
out <- genoud(nvars = nrow(indu), fn = fun, ind_n.Freq = indu, con = cons[1,], control = list(maxit = 1000), data.type.int = TRUE, Domains = matrix(c(rep(0, nrow(indu)),rep(100000, nrow(indu))), ncol = 2))
out$par
fun(par = out$par, ind_n.Freq = indu, con = cons)
fun(par = c(2,2,1,6), ind_n.Freq = indu, con = cons)

opt_res <- data.frame(algorithm = NA,
  maxit = NA,
  fit = NA,
  time = NA)
init<-fun(par = rep(1,nrow(indu)), ind_n.Freq = indu, con = cons)
opt_res <- rbind(opt_res, c("optim_Nelder", 0,init, NA))
opt_res <- rbind(opt_res, c("optim_SANN", 0,init, NA))
opt_res <- rbind(opt_res, c("optim_BFGS", 0,init, NA))
opt_res <- rbind(opt_res, c("optim_CG", 0,init, NA))
opt_res <- rbind(opt_res, c("ipf", 0,init, NA))
opt_res <- rbind(opt_res, c("GenSA", 0,init, NA))

Nb = 11 # default iteration number
set.seed(2014)
for(i in 1:Nb){
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_Nelder", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i ))
  opt_res <- rbind(opt_res, c("optim_SANN", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_BFGS", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_CG", i, tmp_res$value, NA))
  weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))
  opt_res <- rbind(opt_res, c("ipf", i, tae, NA))
  tmp_res <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_n.Freq = indu, con = cons[1,])
  opt_res <- rbind(opt_res, c("GenSA", i, tmp_res$value, NA))
}

opt_res$fit <- as.numeric(opt_res$fit)
opt_res$maxit <- as.numeric(opt_res$maxit)

qplot(data = opt_res, maxit, fit, linetype = algorithm, geom="line") +
  ylab("Total Absolute Error") + xlab("Iterations") +
  scale_linetype(name = "Algorithm") +
   #scale_color_brewer(palette = 2, type = "qual") + 
  theme_classic()
# Save the plots! 
# ggsave("figures/optim-its.png") # (original plot)
# ggsave("figures/TAEOptim_GenSA_Mo.png")
# ggsave("figures/TAEOptim_GenSA_Mo.pdf")



# Regenerate results for timings plot
opt_res <- data.frame(algorithm = NA,
  maxit = NA,
  fit = NA,
  time = NA)


Nb = 11 # default iteration number
set.seed(2014)
for(i in 1:Nb){
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_Nelder", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_SANN", i , tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_BFGS", i, tmp_res$value, NA))
  tmp_res <- optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))
  opt_res <- rbind(opt_res, c("optim_CG", i, tmp_res$value, NA))
  weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))
  opt_res <- rbind(opt_res, c("ipf", i, tae, NA))
  tmp_res <- GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_n.Freq = indu, con = cons[1,])
  opt_res <- rbind(opt_res, c("GenSA", i, tmp_res$value, NA))
}

opt_res$fit <- as.numeric(opt_res$fit)
opt_res$maxit <- as.numeric(opt_res$maxit)

### Timings
mb <- NULL
for(i in 1:Nb){
  Nelder <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "Nelder-Mead", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i ))}
  SANN <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "SANN", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i ))}
  BFGS <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "BFGS", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))}
  CG <- function(){optim(par = rep(1, nrow(indu)), fn = fun, method = "CG", ind_n.Freq = indu, con = cons[1,], control = list(maxit = i))}
  IPF <- function(){weights <- apply(cons, 1, function(x) ipfp(x, ind_catt, x0, maxit = i ))
  tae <- sum(abs(colSums(weights[,1] * ind_cat) - cons[1,]))}
  GENSA <- function(){GenSA(par = rep(1, nrow(indu)), fn = fun, lower = rep(0, nrow(indu)), upper = rep(10^2, nrow(indu)), control = list(maxit = i), ind_n.Freq = indu, con = cons[1,])}
  mb <- rbind(mb, print(microbenchmark(Nelder(), SANN(), BFGS(), CG(), IPF(), GENSA(), times = 20)))
}

opt_res[2:dim(opt_res)[1],]$time <-  mb$mean
opt_res$time<-as.numeric(opt_res$time)

qplot(data = opt_res, maxit, time, linetype = algorithm, geom="line") +
#   ylim(NA, 3000) +
  coord_cartesian(ylim = c(0, 2000)) +
  ylab("Time (microseconds)") +
  xlab("Number of iterations") +
  scale_colour_brewer(palette = 2, type = "div") +
  scale_linetype(name = "Algorithm") +
  theme_classic() 
# Save the plots!
# ggsave("figures/optim-time.png")
# ggsave("figures/TimeOptim_GenSA_Mo.png")
# ggsave("figures/TimeOptim_GenSA_Mo.pdf")
### Background

# plot of time vs TAE
qplot(data = opt_res, time, fit, linetype = algorithm, geom="line") +
  ylab("TAE") + xlab("Time (microseconds)") + scale_color_brewer(palette = 2, type = "qual") + theme_classic() 


### Stack overflow - simplest form - representation of the above
# See http://stackoverflow.com/questions/26160079/fast-concise-way-to-generate-ordered-frequency-count-of-unique-matrix-rows

